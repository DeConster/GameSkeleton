Что нужно для простейшего платформера?

1. Графика
  1.1 Vulcan не щупал
    Основная идея сделать фреймворк/враппер над вулканом, чтоб получить что-то вроде такого:
  public void draw(Sprite &a)
  Для этой функции иметь всевозможные перегрузки для удобства и не видеть и не пересекаться с реализацией
  отрисовки. (Пример скелета будет прилагаться к данному файлу). Основная цель отделить и сделать модулем
  всю отрисовку.
  1.2 Анимация
    Для Марио, будем использовать примитивнейшую анимацию, а именно спрайтовую. Тут все просто. Есть массив из 4 картинок Марио в разных позах
  хотьбы. Затем, если мы зажали кнопку, в цикле использовать такой прекрасный трюк как:
  i = 0;
  frame = i++ % mas.size();
  Вот и вся анимация. Сохранить основное состояние Марио и при нажатии проигрывать анимацию, а при отжатии кнопки, устанавливать в сохраненное
  состояние. Можно установить основное состояние при "0" индексе и при отжатии сбрасывать кадр в состояние при 0 индексе.
  1.3 Карта
    Есть карта, которую можно сделать раазными путями, я знаю только два. Первый, это представить карту в виде строки, а второй это делать карту с
  помощью файлов специальных форматов (Когда делал игру для Gameloft юзал какую-то прогу... Tiled вроде). Нам достаточно строки. Пример:
  Map = 
  "1000000001"
  "1000111001"
  "1000000001"
  "1111111111"
  Каждая цифра обозначает свой вид блока. В данном случае 0 - прозрачный, 1 - твердый. Возьмем за должное, что каждый тайл в игре будет 32х32 пикселя.
  Это не обязательно, по желанию. Тогда мы имеет простую математику со смещениями. Имея длинну и высоту уровня (в тайлах. В данном случае 10х4) мы можем
  нарисовать любой из них по формулам х = dx * 32, у = dу * 32. В цикле рисуем все тайлы.
  1.4 Камера
    Этот пункт последним пишу... чуть не забыл!!! Карта твоя, вполне может быть больше чем обзор (зачастую так и бывает). По этому используется камера.
  Грубо говоря, это прямоугольник, который ты видишь, остальная часть карты, вне прямоугольника. Так как твой персонаж двигается по карте, то камера должна
  следовать за персонажем и тут есть что отметить. При прыжке и движении в стороны, твоя камера двигается соответственно, но есть проблема с углами карты.
  Если дать камере возможность двигаться соответственно движениям персонажа, то когда ты подойдешь к краю карты, то камера выйдет за пределы карты и это
  будет не круто. (Так как твой персонаж по середине камеры, зачастую, то когда ты подходишь к краю карты, то половина камеры выходит за нее). Чтоб этого
  избежать, нужно проверять не край ли карты и если это так, то не давать камере двигаться по этой оси. Пример будет приведен в коде скелета.

2. Управление
  2.1 Обработка перефирии
    Есть паттерн, который по слухам хорошо помогает для организации обработки. Паттерн команда. Сам опять таки не знаю =(
  2.2 Движение
    Движение может осуществляться при помощи моделирования векторной скорости (Можно расширить с добавлением ускорения). Можно
  использовать спинномозговой подход к скорости (Прибавлять к anchor point* количество пикселей).
  2.3 Ограничение фпс
    Так как это простейший платформер, то ограничение фпс будет влиять только на управление, по этому записал в управление.
    Даже слабые процессоры, без ограничения в фпс херачят с дикой скоростью.

3. Физика
  3.1 Гравитация
    То же самое, что и движение. Реализация может быть как просто "-n" к координате у, так и через векторную скорость. Под векторной
  скоростью я подозреваю некоторую пару чисел V(x,y), которая будет прибавляться к текущим координатам. В бесконечном цикле будет происходить
  что-то вроде х += V(x), y += V(y). Если ничего не нажимать, то вектор V(x,y), будет равен 0 и движения не будет. При нажатии добавлять
  вектор направления персонажа к вектору скорости. Пример: (При нажатии кнопки в право, будет происходить: V(x,y) + D(n,0), при нажатии кнопки
  в лево, будет происходить V(x,y) + D(-n,0) и т. д.).
  Вернемся к гравитации... сорян, отвлекся. Гравитация это вечное падение на V(0,n) (Тут еще стоит отметить... важная штука, которую я заметил.
  Если мы работаем в системе координат окна, то ось у инвертирована, так как точка (0,0) у нас в верхнем левом углу и из-за этого нужно, либо
  перевести в свою систему координат, либо извращаться с инверсией, чего не советую...). Итак... гравитация. К ней можно добавить не просто
  падение, а еще и ускорение, что прибавит реалистичности. Так как в марио есть и скорость и ускорение, мы выбираем сложный ваниант с учитыванием
  всех этих прекрасных штук.
  3.2 Перемещение
    По тому же принципу, что и гравитация. Либо красиво через векторы, либо по супер простому.
  3.3 Обработка коллизий
    С вечным падением, лететь долго и долго... Нужно взаимодействовать с землей и другими твердыми тайлами. Это выглядит примерно так...
  Все в тайлах, значит у всех есть бокс. Так как Марио в квадрате, значит используем обработку коллизий AABB (Axis-Aligned Bounding Box).
  Таким образом мы можем при возникновении коллизии Марио с препятствием тормозить его, прямо повлияв на скорость. Можно упороться и вообще организовать это как
  3 закон Ньютона (Тела действуют друг на друга с силами, равными по модулю и противоположными по направлению), то есть получать скорость Марио и вжарить ему такую
  же скорость только со знаком минус. Но это я увлекся, для простой игры не нужна реальная физика, хватит просто остановить.

Итак... Вроде бы расписал все что мог, если что упустил, то спрашивай. Для простейшего платформера, вроде все необходимое есть. Если захочешь использовать бонусы, то
по той же механике. Грибок, это просто анимация растущего грибка, а затем простейший AI(artificial intelligence) идти пока не встретит препятствие, а потом инвертировать
скорость по знаку. Цветочек, это просто анимация цветочка. Пульки аналогично грибку, только со своим поведением.